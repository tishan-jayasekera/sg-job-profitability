{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Job Profitability Analysis ‚Äî Exploratory Data Analysis\n",
    "\n",
    "## Metric Definitions\n",
    "\n",
    "| Metric | Formula |\n",
    "|--------|--------|\n",
    "| **Quoted Amount** | `[Job Task] Quoted Amount` |\n",
    "| **Billable Value** | `Actual Hours √ó [Task] Billable Rate` |\n",
    "| **Cost (T&M)** | `Actual Hours √ó [Task] Base Rate` |\n",
    "| **Profit** | `Billable Value - Cost` |\n",
    "| **Margin %** | `(Profit / Billable Value) √ó 100` |"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import sys\n",
    "sys.path.append('..')\n",
    "\n",
    "from analysis import (\n",
    "    load_raw_data, clean_and_parse, apply_filters,\n",
    "    compute_reconciliation_totals, get_available_fiscal_years,\n",
    "    compute_category_summary, compute_job_summary, compute_task_summary,\n",
    "    calculate_overall_metrics, analyze_overrun_causes,\n",
    "    get_top_overruns, get_loss_making_jobs, get_unquoted_tasks,\n",
    "    METRIC_DEFINITIONS\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Configuration\n",
    "DATA_PATH = '../data/Quoted_Task_Report_FY26.xlsx'\n",
    "\n",
    "# Load and parse raw data\n",
    "df_raw = load_raw_data(DATA_PATH)\n",
    "df_parsed = clean_and_parse(df_raw)\n",
    "\n",
    "print(f\"Raw records: {len(df_raw):,}\")\n",
    "print(f\"Parsed records: {len(df_parsed):,}\")\n",
    "print(f\"Fiscal Years: {get_available_fiscal_years(df_parsed)}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Apply Filters and Reconcile"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Apply standard filters\n",
    "df, recon = apply_filters(\n",
    "    df_parsed,\n",
    "    exclude_sg_allocation=True,  # Exclude \"Social Garden Invoice Allocation\"\n",
    "    billable_only=True,          # Only tasks with Base Rate > 0 AND Billable Rate > 0\n",
    "    fiscal_year=None             # All years (or set to e.g. 2026 for FY26)\n",
    ")\n",
    "recon = compute_reconciliation_totals(df, recon)\n",
    "\n",
    "print(\"RECONCILIATION\")\n",
    "print(\"=\"*50)\n",
    "print(f\"Raw records:              {recon['raw_records']:,}\")\n",
    "print(f\"Excluded (SG Allocation): {recon['excluded_sg_allocation']:,}\")\n",
    "print(f\"Excluded (Non-Billable):  {recon['excluded_non_billable']:,}\")\n",
    "print(f\"Excluded (Other FY):      {recon['excluded_other_fy']:,}\")\n",
    "print(f\"Final records:            {recon['final_records']:,}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Validation totals\n",
    "print(\"\\nVALIDATION TOTALS\")\n",
    "print(\"=\"*50)\n",
    "for key, val in recon['totals'].items():\n",
    "    if 'sum' in key:\n",
    "        print(f\"{key}: {val:,.2f}\")\n",
    "    else:\n",
    "        print(f\"{key}: {val:,}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Compute Summaries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "category_summary = compute_category_summary(df)\n",
    "job_summary = compute_job_summary(df)\n",
    "task_summary = compute_task_summary(df)\n",
    "\n",
    "print(f\"Categories: {len(category_summary)}\")\n",
    "print(f\"Jobs: {len(job_summary):,}\")\n",
    "print(f\"Task records: {len(task_summary):,}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Overall Metrics"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "metrics = calculate_overall_metrics(job_summary)\n",
    "\n",
    "print(\"OVERALL PERFORMANCE\")\n",
    "print(\"=\"*50)\n",
    "print(f\"Total Jobs:           {metrics['total_jobs']:,}\")\n",
    "print(f\"Quoted Amount:        ${metrics['total_quoted_amount']:,.0f}\")\n",
    "print(f\"Billable Value:       ${metrics['total_billable_value']:,.0f}  (Hrs √ó Billable Rate)\")\n",
    "print(f\"Cost (T&M):           ${metrics['total_cost_tm']:,.0f}  (Hrs √ó Base Rate)\")\n",
    "print(f\"Profit:               ${metrics['total_profit']:,.0f}\")\n",
    "print(f\"Margin %:             {metrics['overall_margin_pct']:.1f}%\")\n",
    "print()\n",
    "print(f\"Jobs Over Budget:     {metrics['jobs_over_budget']} ({metrics['overrun_rate']:.1f}%)\")\n",
    "print(f\"Jobs at Loss:         {metrics['jobs_at_loss']} ({metrics['loss_rate']:.1f}%)\")\n",
    "print(f\"Hours Variance:       {metrics['hours_variance']:+,.0f} ({metrics['hours_variance_pct']:+.1f}%)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Category Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Categories sorted by margin\n",
    "category_summary.sort_values('Margin_Pct')[[\n",
    "    'Category', 'Job_Count', \n",
    "    'Quoted_Hours', 'Actual_Hours', 'Hours_Variance_Pct',\n",
    "    'Quoted_Amount', 'Billable_Value', 'Cost_TM',\n",
    "    'Profit', 'Margin_Pct'\n",
    "]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Chart: Margin by category\n",
    "fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n",
    "\n",
    "cat_sorted = category_summary[category_summary['Billable_Value'] > 0].sort_values('Margin_Pct')\n",
    "\n",
    "# Margin %\n",
    "colors = ['#e53935' if m < 20 else '#43a047' for m in cat_sorted['Margin_Pct']]\n",
    "axes[0].barh(cat_sorted['Category'], cat_sorted['Margin_Pct'], color=colors)\n",
    "axes[0].axvline(x=0, color='black', linewidth=0.5)\n",
    "axes[0].axvline(x=20, color='orange', linestyle='--')\n",
    "axes[0].set_xlabel('Margin %')\n",
    "axes[0].set_title('Margin % by Category')\n",
    "\n",
    "# Hours Variance %\n",
    "colors2 = ['#e53935' if v > 20 else '#1e88e5' for v in cat_sorted['Hours_Variance_Pct']]\n",
    "axes[1].barh(cat_sorted['Category'], cat_sorted['Hours_Variance_Pct'], color=colors2)\n",
    "axes[1].axvline(x=0, color='black', linewidth=0.5)\n",
    "axes[1].set_xlabel('Hours Variance %')\n",
    "axes[1].set_title('Hours Variance by Category')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Job-Level Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Lowest margin jobs\n",
    "print(\"BOTTOM 15 JOBS BY MARGIN %\")\n",
    "job_summary.nsmallest(15, 'Margin_Pct')[[\n",
    "    'Job_No', 'Job_Name', 'Client',\n",
    "    'Quoted_Hours', 'Actual_Hours', 'Hours_Variance_Pct',\n",
    "    'Quoted_Amount', 'Billable_Value', 'Cost_TM',\n",
    "    'Profit', 'Margin_Pct', 'Margin_Erosion'\n",
    "]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Margin scatter: Quoted vs Actual\n",
    "quoted_jobs = job_summary[job_summary['Quoted_Amount'] > 0]\n",
    "\n",
    "fig, ax = plt.subplots(figsize=(10, 8))\n",
    "colors = ['#e53935' if m < q else '#43a047' \n",
    "          for m, q in zip(quoted_jobs['Margin_Pct'], quoted_jobs['Quoted_Margin_Pct'])]\n",
    "ax.scatter(quoted_jobs['Quoted_Margin_Pct'], quoted_jobs['Margin_Pct'], c=colors, alpha=0.5, s=30)\n",
    "ax.plot([-50, 100], [-50, 100], 'k--', alpha=0.3)\n",
    "ax.set_xlim(-50, 100)\n",
    "ax.set_ylim(-50, 100)\n",
    "ax.set_xlabel('Quoted Margin %')\n",
    "ax.set_ylabel('Actual Margin %')\n",
    "ax.set_title('Margin: Quoted vs Actual\\n(Below diagonal = erosion)')\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "erosion = (quoted_jobs['Margin_Pct'] < quoted_jobs['Quoted_Margin_Pct']).sum()\n",
    "print(f\"Jobs with margin erosion: {erosion} / {len(quoted_jobs)} ({erosion/len(quoted_jobs)*100:.1f}%)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Task-Level Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Unquoted tasks (scope creep)\n",
    "unquoted = get_unquoted_tasks(task_summary)\n",
    "print(f\"UNQUOTED TASKS: {len(unquoted):,}\")\n",
    "print(f\"Total Cost (T&M): ${unquoted['Cost_TM'].sum():,.0f}\")\n",
    "print(f\"Total Hours: {unquoted['Actual_Hours'].sum():,.0f}\")\n",
    "print()\n",
    "unquoted.head(15)[['Job_No', 'Job_Name', 'Task_Name', 'Actual_Hours', 'Cost_TM', 'Base_Rate', 'Billable_Rate']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Top overrun tasks (that had quotes)\n",
    "overrun_tasks = task_summary[\n",
    "    (task_summary['Is_Overrun']) & \n",
    "    (~task_summary['Is_Unquoted']) &\n",
    "    (task_summary['Quoted_Hours'] > 0)\n",
    "].nlargest(15, 'Hours_Variance')\n",
    "\n",
    "print(\"TOP 15 TASKS BY HOUR OVERRUN\")\n",
    "overrun_tasks[[\n",
    "    'Job_No', 'Job_Name', 'Task_Name',\n",
    "    'Quoted_Hours', 'Actual_Hours', 'Hours_Variance', 'Hours_Variance_Pct'\n",
    "]]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Synthesis: Why Jobs Run Over"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "causes = analyze_overrun_causes(task_summary)\n",
    "\n",
    "print(\"OVERRUN CAUSES\")\n",
    "print(\"=\"*50)\n",
    "\n",
    "print(\"\\nüìå SCOPE CREEP (Unquoted Tasks)\")\n",
    "print(f\"   Tasks: {causes['scope_creep']['task_count']:,}\")\n",
    "print(f\"   Cost:  ${causes['scope_creep']['total_cost']:,.0f}\")\n",
    "print(f\"   Hours: {causes['scope_creep']['total_hours']:,.0f}\")\n",
    "\n",
    "print(\"\\n‚è±Ô∏è UNDERESTIMATION (Overrun Tasks)\")\n",
    "print(f\"   Tasks:        {causes['underestimation']['task_count']:,}\")\n",
    "print(f\"   Excess Hours: {causes['underestimation']['excess_hours']:,.0f}\")\n",
    "\n",
    "print(\"\\nüìù UNBILLED WORK\")\n",
    "print(f\"   Tasks:          {causes['unbilled_work']['task_count']:,}\")\n",
    "print(f\"   Unbilled Hours: {causes['unbilled_work']['unbilled_hours']:,.0f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Top overruns and losses\n",
    "print(\"\\nüö® TOP 10 JOB OVERRUNS\")\n",
    "display(get_top_overruns(job_summary, 10, 'Hours_Variance')[[\n",
    "    'Job_No', 'Job_Name', 'Client', 'Hours_Variance', 'Profit', 'Margin_Pct'\n",
    "]])\n",
    "\n",
    "print(\"\\nüí∏ LOSS-MAKING JOBS\")\n",
    "losses = get_loss_making_jobs(job_summary)\n",
    "print(f\"Count: {len(losses)}\")\n",
    "print(f\"Total Losses: ${losses['Profit'].sum():,.0f}\")\n",
    "display(losses.head(10)[['Job_No', 'Job_Name', 'Client', 'Profit', 'Margin_Pct', 'Cost_TM']])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Metric Definitions Reference"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Print all metric definitions\n",
    "for key, defn in METRIC_DEFINITIONS.items():\n",
    "    print(f\"\\n{defn['name']}\")\n",
    "    print(f\"  Formula: {defn['formula']}\")\n",
    "    print(f\"  {defn['description']}\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.10.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}